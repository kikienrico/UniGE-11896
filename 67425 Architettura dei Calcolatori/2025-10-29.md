**Class**: [[11896 INFORMATICA/Classes/67425 - Architettura dei Calcolatori|67425 - Architettura dei Calcolatori]]
**Date**: 2025-10-29
**Topics**:
**Books**:

### IF in RISC-V
In C++:
``` C++
if (b!=c) a=b+c;
else a=b-c;
```

In RISC-V:
``` C++
if (b==c) a=b+c;
//metto un etichetta che mi faccia saltare l'else
else a=b-c;
```
``` C++
s3=a, s4=b, s5=c
beq s4, s5, Lab1 (if (b==c)) //Lab1 etichetta di offset 
add s3, s4, s5 (a=b+c)
beq x0, x0, Lab2 (if (x0==x0)) //istruzione che sarà sempre vera, se un registro con se stesso sarà uguale
Lab1 sub s3, s4, s5 (a=b-c)

Lab2 ...
```

**Istruzioni.**
- Branch == → beq
- Branch != → bne
- Branch < → 

### Esercizio
Tradurre in assembler l’istruzione: `if (i==j) f=g+h; else f=g-h; con f-j in x19-x23`

``` C++
i=x22, j=x23, f=x19, g=x20, h=x21

bne x22, x23, salto //se non è verificato salto a "salto"
add x19, x20, x21
beq x0, x0, salto1 //sempre verificata quindi salto a "salto1"
salto: sub x19, x21

salto1:

(se la condizione è true il salto avviene, altrimenti no)
```

Tradurre in assembler l’istruzione: `while(salva[i]==k) i++;`
``` C++
x25=salva[], x22=i, x24=k

SLLI x26, x22, 3 //shift left immediate (x26=i*8)

loop: ADD x26, x25, x26
LD x26, 0(x26)
BNE x26, x24, pippo
ADDi x22, x22, 1
beq x26, x26, loop

pippo:
```

Commentato:
``` C++
# Contesto iniziale:
# x25 = salva[] (indirizzo base dell'array)
# x22 = i (indice corrente)
# x24 = k (valore da cercare)

SLLI x26, x22, 3      # x26 = i * 8 (offset in byte)
loop: 
    ADD x26, x25, x26  # x26 = indirizzo di salva[i]
    LD x26, 0(x26)     # x26 = valore di salva[i]
    BNE x26, x24, pippo # se salva[i] != k, esci
    ADDI x22, x22, 1   # i++
    BEQ x26, x26, loop # jump incondizionato a loop
pippo:
    # fine del ciclo
```

**Analisi completa**

**SLLI** → significa che sposto $x22$ di $3$ posizioni a sinistra, e lo salvo in $x26$, essendo che sono operazioni a bit, spostando di $3$ posizioni a sinistra moltiplico per $2^3$ ($2^{n.posizioni}$)
**Alternativa a SLLI** → per fare la moltiplicazione senza shift faccio `addi x27, x0, 8` e poi `mul x26, x23, x27`

> [!info] 
> **Quando si usa ADDi?** 
> ADDi (add immediate) si usa quando si devono sommare costanti (1,2,3,4,5…), se devo fare somme tra registri basta usare ADD

