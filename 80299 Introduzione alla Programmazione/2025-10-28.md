**Class**: [[11896 INFORMATICA/Classes/80299 - Introduzione alla Programmazione|80299 - Introduzione alla Programmazione]]
**Date**: 2025-10-28
**Topics**:
**Books**:

### Algoritmi di sorting (data una sequenza v metterla in ordine)
- **Selection sort**
	1) **Selection sort** → cerco l’elemento più piccolo della sequenza e lo scambio di posto al primo
	2) **Ripeto** 1) sulla sequenza che inizia con l’elemento successivo
	3) Mi fermo quando ho messo a posto il **penultimo** elemento
- **Algoritmi IN-PLACE** → non necessario di fare copia delle sequenze o avere numero aggiuntivo dello stesso ordine di grandezza
- **Concetto di INVARIANTE** → condizione che è sempre vera a tutti i passi dell’algoritmo
1) **INVARIANTE nel selection sort** → La parte sinistra è ordinata e contiene tutti elementi più piccoli di quelli di destra
	- All’inizio → parte *sx* **vuota**, parte *dx* **tutto**
	- Alla fine → parte *sx* **piena**, parte *dx* **vuota**

``` C++
vector<T> v;

//riempio v

for (int i=0; i<v.size()-1; i++) { //metto a posto
	int posmin=i; //supponiamo che l'elemento più piccolo sia i
	
	for (int j=i+1; j<v.size(); j++) //cerca minimo
		if(v[posmin]>v[j]) posmin=j;
	
	T temp=v[i];
	v[i]=v[posmin];
	v[posmin]=temp;
}
```

### Come si scambiano due variabili?
Per fare uno scambio tra due variabili mi serve una terza variabile temporale in cui salvare uno dei due valori, dati $a, b, temp$, salvo il valore di $a$ in $temp$, poi salvo il valore di $b$ in $a$ e poi salvo il valore di $temp$ in $b$.

### Quanto ci vuole? (analisi di complessità)
**Contiamo**: (Se *v* contiene *n* elementi)
- assegnazioni → ciclo esterno for {n-1 cicli; 4 assegnazioni per ciclo} → $4(n-1)$
- confronti:
	1) 1° ciclo → n-1
	2) 2° ciclo → n-2
	3) 3° ciclo → n-3
	4) …
	5) i° ciclo → n-i-1
	Quindi $\frac{n^2}{2}-\frac{n}{2}$

### Insertion sort
- **INVARIANTE** → gli elementi a sinistra sono ordinati tra loro.

``` C++
vector<T> v;
//riempio v

for (int i=0; i<v.size(); i++) //metto a post l'elemento i
	for (int i=j; j>0; j--)
		if(v[j]>v[i]) {
		T temp=v[i]; v[i]=v[j]; v[j]=temp;
		} else break;

```

##### Oppure (più efficiente)

``` C++
vector<T> v;
//riempio v

for (int i=1; i<v.size(); i++) //metto a post l'elemento i
	if(v[i]<v[i-1]) {
		T temp=v[i];
		int j=i;
		do {
			v[j]=v[j-1];
			j--;
		} while (v[j]<v[j-1] && j>0)
		v[j]=temp;
	}

```